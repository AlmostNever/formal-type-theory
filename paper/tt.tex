\section{Type theory}
\label{sec:type-theory}

In this section we give the formulation of type theory that we shall work with.

\subsection{Syntax}
\label{sec:syntax}

\begin{align*}
  \text{Context $\G$, $\D$}
    \bnf   {}& \ctxempty                && \text{empty context} \\
    \bnfor {}& \ctxextend{\G}{\A}       && \text{context $\G$ extended with $\A$} \\
  \\
  \text{Type $\A$, $\B$, $\C$}
    \bnf   {}& \Prod{\A} \B             && \text{product}\\
    \bnfor {}& \Id{\A}{\uu}{\vv}        && \text{identity type} \\
    \bnfor {}& \subst{\A}{\sbs}         && \text{substitution $\sbs$ applied to $\A$} \\
    \bnfor {}& \Empty                   && \text{empty type} \\
    \bnfor {}& \Unit                    && \text{unit type} \\
    \bnfor {}& \Bool                    && \text{bool type} \\
  \\
  \text{Term $\uu$, $\vv$, $\ww$}
    \bnf   {}& \var{k}                  && \text{the $k$-th variable index (a la de Bruijn)} \\
    \bnfor {}& \lam{\A}{\B} \uu         && \text{$\lambda$-abstraction} \\
    \bnfor {}& \app{\uu}{\A}{\B}{\vv}   && \text{application} \\
    \bnfor {}& \refl{\A} \uu            && \text{reflexivity} \\
    \bnfor {}& \J{\A}{\uu}{\C}{\ww}{\vv}{\p} && \text{the J eliminator} \\
    \bnfor {}& \subst{\uu}{\sbs}        && \text{substitution $\sbs$ applied to $\uu$} \\
    \bnfor {}& \exfalso{\A} \uu         && \text{ex falso quod libet} \\
    \bnfor {}& \unit                    && \text{the unit inhabitant} \\
    \bnfor {}& \true                    && \text{true} \\
    \bnfor {}& \false                   && \text{false} \\
    \bnfor {}& \cond{\A}{\uu}{\vv}{\ww} && \text{conditional term} \\
  \\
  \text{Substitution $\sbs$, $\sbt$}
    \bnf   {}& \sbzero{\G}{\A}{\uu}     && \text{substitute $u$ for the $0$-th index} \\
    \bnfor {}& \sbweak{\G}{\A}          && \text{weakening substitution $\ctxextend{\G}{\A} \to \G$} \\
    \bnfor {}& \sbshift{\G}{\A}{\sbs}   && \text{shift substitution} \\
    \bnfor {}& \sbid{\G}                && \text{identity substitution} \\
    \bnfor {}& \sbcomp{\sbs}{\sbt}      && \text{composition of substitutions}
\end{align*}

\subsection{Judgments}
\label{sec:judgments}

\begin{align*}
& \isctx{\G}                    && \text{$\G$ is a context} \\
& \issubst{\sbs}{\G}{\D}        && \text{$\sbs$ is a substitution from context $\G$ to context $\D$} \\
& \istype{\G}{\A}               && \text{$\A$ is a type in context $\G$} \\
& \isterm{\G}{\uu}{\A}          && \text{$\uu$ is a term of type $\A$ in context $\G$} \\
& \eqctx{\G}{\D}                && \text{$\G$ and $\D$ are equal contexts} \\
& \eqsubst{\sbs}{\sbt}{\G}{\D}  && \text{$\sbs$ and $\sbt$ are equal substitutions from context $\G$ to context $\D$} \\
& \eqtype{\G}{\A}{\B}           && \text{$\A$ and $\B$ are equal types in context $\G$} \\
& \eqterm{\G}{\uu}{\vv}{\A}     && \text{$\uu$ and $\vv$ are equal terms of type $\A$ in context $\G$}
\end{align*}

\subsection{Contexts \fbox{$\isctx{\G}$}}
\label{sec:contexts}

\begin{mathpar}
  {\label{rul:ctx-empty} \showCtxEmpty}

  {\label{rul:ctx-extend} \showCtxExtend}
\end{mathpar}

\subsection{Substitutions \fbox{$\issubst{\sbs}{\G}{\D}$}}
\label{sec:subst}

\begin{mathpar}
  {\label{rul:subst-zero} \showSubstZero}

  {\label{rul:subst-weak} \showSubstWeak}

  {\label{rul:subst-shift} \showSubstShift}

  {\label{rul:subst-id} \showSubstId}

  {\label{rul:subst-comp} \showSubstComp}

  {\label{rul:subst-ctx-conv} \showSubstCtxConv}
\end{mathpar}

\subsection{Types \fbox{$\istype{\G}{\A}$}}

\subsubsection*{General rules}

\begin{mathpar}
  {\label{rul:ty-ctx-conv} \showTyCtxConv}

  {\label{rul:ty-subst} \showTySubst}
\end{mathpar}

\subsubsection*{Type formers}

\begin{mathpar}
  {\label{rul:ty-prod} \showTyProd}

  {\label{rul:ty-id} \showTyId}

  {\label{rul:ty-empty} \showTyEmpty}

  {\label{rul:ty-unit} \showTyUnit}

  {\label{rul:ty-bool} \showTyBool}
\end{mathpar}

\subsection{Terms \fbox{$\isterm{\G}{\uu}{\A}$}}

\subsubsection*{General rules}
\begin{mathpar}
  {\label{rul:term-ty-conv} \showTermTyConv}

  {\label{rul:term-ctx-conv} \showTermCtxConv}

  {\label{rul:term-subst} \showTermSubst}
\end{mathpar}

\subsubsection*{Variables}

\begin{mathpar}
  {\label{rul:term-var-zero} \showTermVarZero}

  {\label{rul:term-var-succ} \showTermVarSucc}
  \end{mathpar}

\subsubsection*{Abstraction and application}

\begin{mathpar}
  % Remark: we want \istype{\G}{\A} as a premise because in order to form the
  % product type we need it, and we do not want to resort to inversion on the
  % extended context.
  {\label{rul:term-abs} \showTermAbs}

  % Remark: we want \istype{\ctxextend{\G}{\A}}{\B} because we need to
  % know that \B is a type in \ctxextend{\G}{\A} and we want to avoid
  % inversion on ty-prod.
  {\label{rul:term-app} \showTermApp}
\end{mathpar}


\subsubsection*{Indentity type}

\begin{mathpar}
  {\label{rul:term-refl} \showTermRefl}

  {\label{rul:term-j} \showTermJ}
\end{mathpar}

\subsubsection{Empty type}

\begin{mathpar}
  {\label{rul:term-exfalso} \showTermExfalso}
\end{mathpar}

\subsubsection{Unit type}

\begin{mathpar}
  {\label{rul:term-unit} \showTermUnit}
\end{mathpar}

\subsubsection{Booleans}

\begin{mathpar}
  {\label{rul:term-true} \showTermTrue}

  {\label{rul:term-false} \showTermFalse}

  {\label{rul:term-cond} \showTermCond}
\end{mathpar}


\subsection{Context equality \fbox{$\eqctx{\G}{\D}$}}
\label{sec:cont-equal}

\subsubsection{General rules}

\begin{mathpar}
  {\label{rul:ctx-refl} \showCtxRefl}

  {\label{rul:ctx-sym} \showCtxSym}

  {\label{rul:ctx-trans} \showCtxTrans}
\end{mathpar}

\subsubsection{Congruence rules}

\begin{mathpar}
  {\label{rul:eq-ctx-empty} \showEqCtxEmpty}

  {\label{rul:eq-ctx-extend} \showEqCtxExtend}
\end{mathpar}

\goodbreak

\subsection{Substitution equality \fbox{$\eqsubst{\sbs}{\sbt}{\G}{\D}$}}

\subsubsection{General rules}

\begin{mathpar}
  {\label{rul:subst-refl} \showSubstRefl}

  {\label{rul:subst-sym} \showSubstSym}

  {\label{rul:subst-trans} \showSubstTrans}

  {\label{rul:eq-subst-ctx-conv} \showEqSubstCtxConv}
\end{mathpar}

\subsubsection{Congruence rules}

\begin{mathpar}
  {\label{rul:cong-subst-zero} \showCongSubstZero}

  {\label{rul:cong-subst-waek} \showCongSubstWeak}

  {\label{rul:cong-subst-shift} \showCongSubstShift}

  {\label{rul:cong-subst-comp} \showCongSubstComp}
\end{mathpar}

\subsubsection{Interaction rules}

\begin{mathpar}
  {\label{rul:weak-nat} \showWeakNat}

  {\label{rul:weak-zero} \showWeakZero}

  {\label{rul:shift-zero} \showShiftZero}

  {\label{rul:comp-shift} \showCompShift}

  {\label{rul:comp-id-right} \showCompIdRight}

  {\label{rul:comp-id-left} \showCompIdLeft}
\end{mathpar}


\goodbreak

\subsection{Type equality \fbox{$\eqtype{\G}{\A}{\B}$}}
\label{sec:type-equality}

\subsubsection*{General rules}

\begin{mathpar}
  {\label{rul:eq-ty-ctx-conv} \showEqTyCtxConv}

  {\label{rul:eq-ty-refl} \showEqTyRefl}

  {\label{rul:eq-ty-sym} \showEqTySym}

  {\label{rul:eq-ty-trans} \showEqTyTrans}
\end{mathpar}

\subsubsection*{Substitution}

\begin{mathpar}
  {\label{rul:eq-ty-id-subst} \showEqTyIdSubst}

  {\label{rul:eq-ty-subst-comp} \showEqTySubstComp}

  {\label{rul:eq-ty-subst-prod} \showEqTySubstProd}

  {\label{rul:eq-ty-subst-id} \showEqTySubstId}

  {\label{rul:eq-ty-subst-empty} \showEqTySubstEmpty}

  {\label{rul:eq-ty-subst-unit} \showEqTySubstUnit}

  {\label{rul:eq-ty-subst-bool} \showEqTySubstBool}

  {\label{rul:eq-ty-exfalso} \showEqTyExfalso}
\end{mathpar}

\subsubsection*{Congruence rules}

\begin{mathpar}
  {\label{rul:cong-prod} \showCongProd}

  {\label{rul:cong-id} \showCongId}

  {\label{rul:cong-ty-subst} \showCongTySubst}
\end{mathpar}

\goodbreak

\subsection{Term equality \fbox{$\eqterm{\G}{\uu_1}{\uu_2}{\A}$}}

\subsubsection*{General rules}

\begin{mathpar}
  {\label{rul:eq-ty-conv} \showEqTyConv}

  {\label{rul:eq-ctx-conv} \showEqCtxConv}

  {\label{rul:eq-refl} \showEqRefl}

  {\label{rul:eq-sym} \showEqSym}

  {\label{rul:eq-trans} \showEqTrans}
\end{mathpar}

\subsubsection*{Substitutions}

\begin{mathpar}
  {\label{rul:eq-id-subst} \showEqIdSubst}

  {\label{rul:eq-subst-comp} \showEqSubstComp}

  {\label{rul:eq-subst-weak} \showEqSubstWeak}

  {\label{rul:eq-subst-zero-zero} \showEqSubstZeroZero}

  {\label{rul:eq-subst-zero-succ} \showEqSubstZeroSucc}

  {\label{rul:eq-subst-shift-zero} \showEqSubstShiftZero}

  {\label{rul:eq-subst-shift-succ} \showEqSubstShiftSucc}

  {\label{rul:eq-subst-abs} \showEqSubstAbs}

  {\label{rul:eq-subst-app} \showEqSubstApp}

  {\label{rul:eq-subst-refl} \showEqSubstRefl}

  \label{rul:eq-subst-j} \showEqSubstJ
\end{mathpar}

\begin{mathpar}
  {\label{rul:eq-subst-exfalso} \showEqSubstExfalso}

  {\label{rul:eq-subst-unit} \showEqSubstUnit}

  {\label{rul:eq-subst-true} \showEqSubstTrue}

  {\label{rul:eq-subst-false} \showEqSubstFalse}

  {\label{rul:eq-subst-cond} \showEqSubstCond}

  {\label{rul:eq-term-exfalso} \showEqTermExfalso}
\end{mathpar}

\subsubsection*{Equality reflection}
%
\begin{mathpar}
  {\label{rul:eq-reflection} \showEqReflection}
\end{mathpar}
%
Here $\mathsf{reflective}(\A)$ is an arbitrary guarding condition that states
that a given type satisfies equality reflection. It implies in particular UIP
for it but needs most likely to be more restrictive.

\subsubsection*{Computation and Extensionality}

\begin{mathpar}
  {\label{rul:unit-eta} \showUnitEta}

  {\label{rul:prod-beta} \showProdBeta}

  {\label{rul:cond-true} \showCondTrue}

  {\label{rul:cond-false} \showCondFalse}

  \label{rul:prod-eta} \showProdEta

  \label{rul:j-refl} \showJRefl
\end{mathpar}

The rule {\rlProdEta} is optional. We may prefer not to keep it around, as it
amounts to function extensionality.

\subsubsection*{Congruence rules}

\begin{mathpar}
  {\label{rul:cong-abs} \showCongAbs}

  {\label{rul:cong-app} \showCongApp}

  {\label{rul:cong-refl} \showCongRefl}

  \label{rul:cong-j} \showCongJ

  {\label{rul:cong-cond} \showCongCond}

  {\label{rul:cong-term-subst} \showCongTermSubst}
\end{mathpar}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
